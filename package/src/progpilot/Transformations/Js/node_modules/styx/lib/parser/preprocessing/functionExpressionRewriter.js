var ESTree = require("../../estree");
var idGenerator_1 = require("../../util/idGenerator");
function rewriteFunctionExpressions(program)
{
    var functionIdGenerator = idGenerator_1.default.create();
    var functionExpressionsToRewrite = [];
    // We're making use of the built-in `JSON.stringify` method here
    // because it accepts a `replacer` callback as its second parameter.
    // That callback gets passed every key and value that's being stringified
    // and can return a different value that's included in the JSON string
    // instead of the original value.
    //
    // This is a poor man's AST visitor, if you will. The idea is that
    // we can easily detect every AST node of type `FunctionExpression` this way.
    // When we encounter such a function expression, we keep track of it
    // and replace the corresponding AST node by a new unique identifier.
    //
    // After the entire program has been visited, we prepend to the program body
    // a function declaration for every function expression we've encountered.
    var stringifiedProgram = JSON.stringify(program, visitNode);
    // The original program is not modified; instead, a clone is created
    var clonedProgram = JSON.parse(stringifiedProgram);
    prependFunctionDeclarationsToProgramBody(functionExpressionsToRewrite, clonedProgram);
    return clonedProgram;
    function visitNode(key, value)
    {
        return value && value.type === ESTree.NodeType.FunctionExpression
            ? rewriteFunctionExpression(value)
            : value;
    }
    function rewriteFunctionExpression(functionExpression)
    {
        var funcId = functionIdGenerator.generateId();
        var nameSuffix = functionExpression.id ? "_" + functionExpression.id.name : "";
        var funcName = "$$func" + funcId + nameSuffix;
        var stringifiedFunctionExpressionBody = JSON.stringify(functionExpression.body, visitNode);
        var rewrittenFunctionExpression = clone(functionExpression);
        rewrittenFunctionExpression.body = JSON.parse(stringifiedFunctionExpressionBody);
        functionExpressionsToRewrite.push({
            name: funcName,
            functionExpression: rewrittenFunctionExpression
        });
        return {
            type: ESTree.NodeType.Identifier,
            name: funcName
        };
    }
}
exports.rewriteFunctionExpressions = rewriteFunctionExpressions;
function prependFunctionDeclarationsToProgramBody(rewrittenFunctions, program)
{
    for (var _i = 0; _i < rewrittenFunctions.length; _i++) {
        var rewrittenFunc = rewrittenFunctions[_i];
        var functionDeclaration = {
            type: ESTree.NodeType.FunctionDeclaration,
            id: {
                type: ESTree.NodeType.Identifier,
                name: rewrittenFunc.name
            },
            params: clone(rewrittenFunc.functionExpression.params),
            body: clone(rewrittenFunc.functionExpression.body)
        };
        program.body.unshift(functionDeclaration);
    }
}
function clone(object)
{
    return JSON.parse(JSON.stringify(object));
}
