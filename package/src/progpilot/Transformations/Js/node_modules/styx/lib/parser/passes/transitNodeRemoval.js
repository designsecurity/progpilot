var numericSet_1 = require("../../collections/numericSet");
var ArrayUtils = require("../../util/arrayUtil");
var flow_1 = require("../../flow");
function removeTransitNodes(graph)
{
    var visitedNodes = numericSet_1.NumericSet.create();
    optimizeNode(graph.entry, visitedNodes);
}
exports.removeTransitNodes = removeTransitNodes;
function optimizeNode(node, visitedNodes)
{
    if (visitedNodes.contains(node.id)) {
        return;
    }
    visitedNodes.add(node.id);
    // Remember target nodes for later traversal
    var targetNodes = node.outgoingEdges.map(function (edge) {
        return edge.target; });
    // We want to simplify transit nodes, but we only ever remove normal nodes
    // because we don't want to mess up references to entry or exit nodes
    if (node.incomingEdges.length === 1 &&
            node.outgoingEdges.length === 1 &&
            node.type === flow_1.NodeType.Normal) {
        var incomingEdge = node.incomingEdges[0];
        var outgoingEdge = node.outgoingEdges[0];
        if (incomingEdge.type === flow_1.EdgeType.Epsilon ||
                outgoingEdge.type === flow_1.EdgeType.Epsilon) {
            optimizeTransitNode(node, visitedNodes);
        }
    }
    for (var _i = 0; _i < targetNodes.length; _i++) {
        var target = targetNodes[_i];
        optimizeNode(target, visitedNodes);
    }
}
function optimizeTransitNode(transitNode, visitedNodes)
{
    // Remember the transit node's original target
    var originalTarget = transitNode.outgoingEdges[0].target;
    if (shouldRemoveTransitNode(transitNode)) {
        removeTransitNode(transitNode);
    }
    // Recursively optimize, starting with the original target
    optimizeNode(originalTarget, visitedNodes);
}
function shouldRemoveTransitNode(transitNode)
{
    var sourceId = transitNode.incomingEdges[0].source.id;
    var target = transitNode.outgoingEdges[0].target;
    for (var _i = 0, _a = target.incomingEdges; _i < _a.length; _i++) {
        var incomingTargetEdges = _a[_i];
        // We only simplify transit nodes if their removal doesn't lead
        // to a node being directly connected to another node by 2 edges
        if (incomingTargetEdges.source.id === sourceId) {
            return false;
        }
    }
    return true;
}
function removeTransitNode(transitNode)
{
    var incomingEdge = transitNode.incomingEdges[0];
    var outgoingEdge = transitNode.outgoingEdges[0];
    var source = incomingEdge.source;
    var target = outgoingEdge.target;
    // Decide whether to keep the incoming or the outgoing edge.
    // If both are epsilon edges, it doesn't matter which one to keep.
    var _a = incomingEdge.type === flow_1.EdgeType.Epsilon
        ? [outgoingEdge, incomingEdge]
        : [incomingEdge, outgoingEdge], edgeToKeep = _a[0], edgeToRemove = _a[1];
    // Redirect surviving edge
    edgeToKeep.source = source;
    edgeToKeep.target = target;
    // Delete both edges from the source
    ArrayUtils.removeElementFromArray(edgeToRemove, source.outgoingEdges);
    ArrayUtils.removeElementFromArray(edgeToKeep, source.outgoingEdges);
    // Delete both edges from the target
    ArrayUtils.removeElementFromArray(edgeToRemove, target.incomingEdges);
    ArrayUtils.removeElementFromArray(edgeToKeep, target.incomingEdges);
    // Add the new edge to both source and target
    source.outgoingEdges.push(edgeToKeep);
    target.incomingEdges.push(edgeToKeep);
    // Clear node
    transitNode.incomingEdges = [];
    transitNode.outgoingEdges = [];
}
