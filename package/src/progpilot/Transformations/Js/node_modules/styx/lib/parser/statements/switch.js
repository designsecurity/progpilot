var negator_1 = require("../expressions/negator");
var stringifier_1 = require("../expressions/stringifier");
var statement_1 = require("./statement");
var estreeFactory_1 = require("../../estreeFactory");
function parseSwitchStatement(switchStatement, currentNode, context, label)
{
    var switchExpressionIdentifier = context.createTemporaryLocalVariableName("switch");
    var switchExpressionAssignment = estreeFactory_1.createAssignmentExpression({
        left: estreeFactory_1.createIdentifier(switchExpressionIdentifier),
        right: switchStatement.discriminant
    });
    var evaluatedDiscriminantNode = context.createNode()
    .appendTo(currentNode, stringifier_1.stringify(switchExpressionAssignment), switchExpressionAssignment);
    var finalNode = context.createNode();
    context.enclosingStatements.push({
        type: 1 /* OtherStatement */,
        breakTarget: finalNode,
        continueTarget: null,
        label: label
    });
    var _a = partitionCases(switchStatement.cases), caseClausesA = _a.caseClausesA, defaultCase = _a.defaultCase, caseClausesB = _a.caseClausesB;
    var stillSearchingNode = evaluatedDiscriminantNode;
    var endOfPreviousCaseBody = null;
    var firstNodeOfClauseListB = null;
    for (var _i = 0, _b = caseClausesA.concat(caseClausesB); _i < _b.length; _i++) {
        var caseClause = _b[_i];
        var matchingCaseCondition = estreeFactory_1.createIdentityComparisonExpression({
            left: estreeFactory_1.createIdentifier(switchExpressionIdentifier),
            right: caseClause.test
        });
        var beginOfCaseBody = context.createNode()
        .appendConditionallyTo(stillSearchingNode, stringifier_1.stringify(matchingCaseCondition), matchingCaseCondition);
        if (caseClause === caseClausesB[0]) {
            firstNodeOfClauseListB = beginOfCaseBody;
        }
        if (endOfPreviousCaseBody && endOfPreviousCaseBody.normal) {
            // We reached the end of the case through normal control flow,
            // which means there was no 'break' statement at the end.
            // We therefore fall through from the previous case!
            beginOfCaseBody.appendEpsilonEdgeTo(endOfPreviousCaseBody.normal);
        }
        endOfPreviousCaseBody = statement_1.parseStatements(caseClause.consequent, beginOfCaseBody, context);
        var nonMatchingCaseCondition = negator_1.negateTruthiness(matchingCaseCondition);
        stillSearchingNode = context.createNode()
        .appendConditionallyTo(stillSearchingNode, stringifier_1.stringify(nonMatchingCaseCondition), nonMatchingCaseCondition);
    }
    if (endOfPreviousCaseBody && endOfPreviousCaseBody.normal) {
        // If the last case didn't end with an abrupt completion,
        // connect it to the final node and resume normal control flow.
        finalNode.appendEpsilonEdgeTo(endOfPreviousCaseBody.normal);
    }
    if (defaultCase) {
        var defaultCaseCompletion = statement_1.parseStatements(defaultCase.consequent, stillSearchingNode, context);
        if (defaultCaseCompletion.normal) {
            var nodeAfterDefaultCase = firstNodeOfClauseListB || finalNode;
            nodeAfterDefaultCase.appendEpsilonEdgeTo(defaultCaseCompletion.normal);
        }
    } else {
        // If there's no default case, the switch statements isn't necessarily exhaustive.
        // Therefore, if no match is found, no clause's statement list is executed
        // and control flow resumes normally after the switch statement.
        finalNode.appendEpsilonEdgeTo(stillSearchingNode);
    }
    context.enclosingStatements.pop();
    return { normal: finalNode };
}
exports.parseSwitchStatement = parseSwitchStatement;
function partitionCases(cases)
{
    var caseClausesA = [];
    var defaultCase = null;
    var caseClausesB = [];
    var isInCaseClausesA = true;
    for (var _i = 0; _i < cases.length; _i++) {
        var switchCase = cases[_i];
        if (switchCase.test === null) {
            // We found the default case
            defaultCase = switchCase;
            isInCaseClausesA = false;
        } else {
            (isInCaseClausesA ? caseClausesA : caseClausesB).push(switchCase);
        }
    }
    return { caseClausesA: caseClausesA, defaultCase: defaultCase, caseClausesB: caseClausesB };
}
