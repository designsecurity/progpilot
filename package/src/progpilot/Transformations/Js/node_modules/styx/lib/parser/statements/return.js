var stringifier_1 = require("../expressions/stringifier");
var flow_1 = require("../../flow");
function parseReturnStatement(returnStatement, currentNode, context) {
	var argument = returnStatement.argument ? stringifier_1.stringify(returnStatement.argument) : "undefined";
	var returnLabel = "return " + argument;
	var finalizerCompletion = runFinalizersBeforeReturn(currentNode, context);
	if (!finalizerCompletion.normal) {
		return finalizerCompletion;
	}
	context.currentFlowGraph.successExit
		.appendTo(finalizerCompletion.normal, returnLabel, returnStatement, flow_1.EdgeType.AbruptCompletion);
	return { return: true };
}
exports.parseReturnStatement = parseReturnStatement;
function runFinalizersBeforeReturn(currentNode, context) {
	var enclosingTryStatements = context.enclosingStatements
		.enumerateElements()
		.filter(function (statement) { return statement.type === 0 /* TryStatement */; });
	for (var _i = 0; _i < enclosingTryStatements.length; _i++) {
		var tryStatement = enclosingTryStatements[_i];
		if (tryStatement.parseFinalizer && !tryStatement.isCurrentlyInFinalizer) {
			tryStatement.isCurrentlyInFinalizer = true;
			var finalizer = tryStatement.parseFinalizer();
			tryStatement.isCurrentlyInFinalizer = false;
			finalizer.bodyEntry.appendEpsilonEdgeTo(currentNode);
			if (finalizer.bodyCompletion.normal) {
				currentNode = finalizer.bodyCompletion.normal;
			}
			else {
				return finalizer.bodyCompletion;
			}
		}
	}
	return { normal: currentNode };
}
