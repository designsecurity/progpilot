var negator_1 = require("../expressions/negator");
var stringifier_1 = require("../expressions/stringifier");
var statement_1 = require("./statement");
var ESTree = require("../../estree");
var estreeFactory_1 = require("../../estreeFactory");
function parseForInStatement(forInStatement, currentNode, context, label) {
	var iteratorFunctionIdentifier = estreeFactory_1.createIdentifier("$$iterator");
	var iteratorCall = estreeFactory_1.createCallExpression(iteratorFunctionIdentifier, [forInStatement.right]);
	var iteratorName = context.createTemporaryLocalVariableName("iter");
	var iteratorIdentifier = estreeFactory_1.createIdentifier(iteratorName);
	var iteratorAssignment = estreeFactory_1.createAssignmentExpression({
left: iteratorIdentifier,
right: iteratorCall
});
var conditionNode = context.createNode()
	.appendTo(currentNode, stringifier_1.stringify(iteratorAssignment), iteratorAssignment);
	var isDoneExpression = {
type: ESTree.NodeType.MemberExpression,
      computed: false,
      object: iteratorIdentifier,
      property: estreeFactory_1.createIdentifier("done")
	};
var isNotDoneExpression = negator_1.negateTruthiness(isDoneExpression);
var startOfLoopBody = context.createNode()
	.appendConditionallyTo(conditionNode, stringifier_1.stringify(isNotDoneExpression), isNotDoneExpression);
var finalNode = context.createNode()
	.appendConditionallyTo(conditionNode, stringifier_1.stringify(isDoneExpression), isDoneExpression);
	var nextElementCallee = {
type: ESTree.NodeType.MemberExpression,
      computed: false,
      object: iteratorIdentifier,
      property: estreeFactory_1.createIdentifier("next")
	};
var propertyAssignment = estreeFactory_1.createAssignmentExpression({
left: getLeftHandSideOfAssignment(forInStatement),
right: estreeFactory_1.createCallExpression(nextElementCallee)
});
var propertyAssignmentNode = context.createNode()
	.appendTo(startOfLoopBody, stringifier_1.stringify(propertyAssignment), propertyAssignment);
	context.enclosingStatements.push({
type: 1 /* OtherStatement */,
breakTarget: finalNode,
continueTarget: conditionNode,
label: label
});
var loopBodyCompletion = statement_1.parseStatement(forInStatement.body, propertyAssignmentNode, context);
context.enclosingStatements.pop();
if (loopBodyCompletion.normal) {
	conditionNode.appendEpsilonEdgeTo(loopBodyCompletion.normal);
}
return { normal: finalNode };
}
exports.parseForInStatement = parseForInStatement;
function getLeftHandSideOfAssignment(forInStatement) {
	if (forInStatement.left.type === ESTree.NodeType.VariableDeclaration) {
		var variableDeclarator = forInStatement.left.declarations[0];
		var variableName = variableDeclarator.id.name;
		return estreeFactory_1.createIdentifier(variableName);
	}
	return forInStatement.left;
}
