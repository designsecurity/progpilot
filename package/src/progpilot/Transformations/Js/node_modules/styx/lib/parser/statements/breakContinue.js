var flow_1 = require("../../flow");
function parseBreakStatement(breakStatement, currentNode, context) {
	var enclosingStatement = findLabeledEnclosingStatement(context, breakStatement.label);
	var finalizerCompletion = runFinalizersBeforeBreakOrContinue(currentNode, context, enclosingStatement);
	if (!finalizerCompletion.normal) {
		return finalizerCompletion;
	}
	enclosingStatement.breakTarget
		.appendTo(finalizerCompletion.normal, "break", breakStatement, flow_1.EdgeType.AbruptCompletion);
	return { break: true };
}
exports.parseBreakStatement = parseBreakStatement;
function parseContinueStatement(continueStatement, currentNode, context) {
	var enclosingStatement = findLabeledEnclosingStatement(context, continueStatement.label);
	if (enclosingStatement.continueTarget === null) {
		throw new Error("Illegal continue target detected: \"" + continueStatement.label + "\" does not label an enclosing iteration statement");
	}
	var finalizerCompletion = runFinalizersBeforeBreakOrContinue(currentNode, context, enclosingStatement);
	if (!finalizerCompletion.normal) {
		return finalizerCompletion;
	}
	enclosingStatement.continueTarget
		.appendTo(finalizerCompletion.normal, "continue", continueStatement, flow_1.EdgeType.AbruptCompletion);
	return { continue: true };
}
exports.parseContinueStatement = parseContinueStatement;
function findLabeledEnclosingStatement(context, label) {
	return context.enclosingStatements.find(function (statement) {
			if (label) {
			// If we have a truthy label, we look for a matching enclosing statement
			return statement.label === label.name;
			}
			// If we don't have a label, we look for the topmost enclosing statement
			// that is not a try statement because that would be an invalid target
			// for `break` or `continue` statements
			return statement.type !== 0 /* TryStatement */;
			});
}
function runFinalizersBeforeBreakOrContinue(currentNode, context, target) {
	var enclosingStatements = context.enclosingStatements.enumerateElements();
	for (var _i = 0; _i < enclosingStatements.length; _i++) {
		var statement = enclosingStatements[_i];
		if (statement.type === 0 /* TryStatement */) {
			var tryStatement = statement;
			if (tryStatement.parseFinalizer && !tryStatement.isCurrentlyInFinalizer) {
				tryStatement.isCurrentlyInFinalizer = true;
				var finalizer = tryStatement.parseFinalizer();
				tryStatement.isCurrentlyInFinalizer = false;
				finalizer.bodyEntry.appendEpsilonEdgeTo(currentNode);
				if (finalizer.bodyCompletion.normal) {
					currentNode = finalizer.bodyCompletion.normal;
				}
				else {
					return finalizer.bodyCompletion;
				}
			}
		}
		if (statement === target) {
			// We only run finalizers of `try` statements that are nested
			// within the target enclosing statement. Therefore, stop here.
			break;
		}
	}
	return { normal: currentNode };
}
