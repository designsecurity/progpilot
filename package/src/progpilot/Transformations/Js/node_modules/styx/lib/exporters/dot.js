var flow_1 = require("../flow");
var ArrayUtil_1 = require("../util/arrayUtil");
function exportAsDot(flowGraph, graphName) {
	return computeDotLines(flowGraph, graphName).join("\n");
}
exports.exportAsDot = exportAsDot;
function computeDotLines(flowGraph, graphName) {
	var entryAndExitNodeList = flowGraph.nodes
		.filter(isExitNode)
		.map(function (node) { return node.id; })
		.join(" ");
	var _a = ArrayUtil_1.partition(flowGraph.edges, function (edge) { return edge.type === flow_1.EdgeType.Conditional; }), conditionalEdges = _a[0], unconditionalEdges = _a[1];
	var innerLines = [
		("node [shape = doublecircle] " + entryAndExitNodeList),
		"node [shape = circle]",
		"",
		"// Unconditional edges"
			].concat(unconditionalEdges.map(formatEdge));
	if (conditionalEdges.length > 0) {
		innerLines.push.apply(innerLines, ["", "// Conditional edges", "edge [color = orange, fontcolor = orange]"].concat(conditionalEdges.map(formatEdge)));
	}
	var graphLines = [
		"digraph control_flow_graph {"
		].concat(innerLines.map(indent), [
				"}"
				]);
	if (graphName) {
		graphLines.unshift("// " + graphName);
	}
	return graphLines;
}
function isExitNode(node) {
	return node.type === flow_1.NodeType.ErrorExit
		|| node.type === flow_1.NodeType.SuccessExit;
}
function indent(line) {
	return "    " + line;
}
function formatEdge(edge) {
	var from = edge.source.id;
	var to = edge.target.id;
	var escapedLabel = escapeDoubleQuotes(edge.label);
	var attributes = edge.label ? " [label = \" " + escapedLabel + "\"]" : "";
	return from + " -> " + to + attributes;
}
function escapeDoubleQuotes(value) {
	return value.replace(/"/g, "\\\"");
}
