var ESTree = require("../../estree");
var numericSet_1 = require("../../collections/numericSet");
var ArrayUtils = require("../../util/arrayUtil");
var flow_1 = require("../../flow");
function rewriteConstantConditionalEdges(graph) {
	var visitedNodes = numericSet_1.NumericSet.create();
	var edgesToRemove = [];
	visitNode(graph.entry, visitedNodes, edgesToRemove);
	for (var _i = 0; _i < edgesToRemove.length; _i++) {
		var edge = edgesToRemove[_i];
		removeEdge(edge);
	}
}
exports.rewriteConstantConditionalEdges = rewriteConstantConditionalEdges;
function visitNode(node, visitedNodes, edgesToRemove) {
	if (visitedNodes.contains(node.id)) {
		return;
	}
	visitedNodes.add(node.id);
	for (var _i = 0, _a = node.outgoingEdges; _i < _a.length; _i++) {
		var edge = _a[_i];
		inspectEdge(edge, edgesToRemove);
		visitNode(edge.target, visitedNodes, edgesToRemove);
	}
}
function inspectEdge(edge, edgesToRemove) {
	if (edge.type !== flow_1.EdgeType.Conditional || edge.data == null || !isCompileTimeConstant(edge.data)) {
		// We only deal with conditional edges that have a condition
		// whose truthiness we can safely determine at compile-time
		return;
	}
	if (isAlwaysTruthy(edge.data)) {
		// Conditional edges with a constant truthy test are always taken;
		// we can therefore turn them into simple epsilon edges
		turnEdgeIntoEpsilonEdge(edge);
	}
	else {
		// Conditional edges with a constant falsy test are never taken;
		// we thus remove this edge after walking the entire graph
		edgesToRemove.push(edge);
	}
}
function isCompileTimeConstant(expression) {
	switch (expression.type) {
		case ESTree.NodeType.Literal:
			return true;
		case ESTree.NodeType.UnaryExpression:
			var unaryExpression = expression;
			return unaryExpression.operator === "!" && isCompileTimeConstant(unaryExpression.argument);
		default:
			return false;
	}
}
function isAlwaysTruthy(expression) {
	switch (expression.type) {
		case ESTree.NodeType.Literal:
			return !!expression.value;
		case ESTree.NodeType.UnaryExpression:
			var unaryExpression = expression;
			if (unaryExpression.operator !== "!") {
				throw Error("This branch shouldn't have been reached");
			}
			return !isAlwaysTruthy(unaryExpression.argument);
		default:
			throw Error("This case shouldn't have been reached");
	}
}
function turnEdgeIntoEpsilonEdge(edge) {
	edge.type = flow_1.EdgeType.Epsilon;
	edge.label = "";
	edge.data = null;
}
function removeEdge(edge) {
	ArrayUtils.removeElementFromArray(edge, edge.source.outgoingEdges);
	ArrayUtils.removeElementFromArray(edge, edge.target.incomingEdges);
}
