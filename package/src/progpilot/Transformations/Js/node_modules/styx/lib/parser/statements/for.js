var variable_1 = require("../declarations/variable");
var negator_1 = require("../expressions/negator");
var stringifier_1 = require("../expressions/stringifier");
var expression_1 = require("./expression");
var statement_1 = require("./statement");
var ESTree = require("../../estree");
function parseForStatement(forStatement, currentNode, context, label) {
	var testDecisionNode = parseInit(forStatement.init, currentNode, context).normal;
	// Create nodes for loop cornerstones
	var beginOfLoopBodyNode = context.createNode();
	var updateNode = context.createNode();
	var finalNode = context.createNode();
	if (forStatement.test) {
		// If the loop has a test expression,
		// we need to add truthy and falsy edges
		var truthyCondition = forStatement.test;
		var falsyCondition = negator_1.negateTruthiness(truthyCondition);
		// Create edges labels
		var truthyConditionLabel = stringifier_1.stringify(truthyCondition);
		var falsyConditionLabel = stringifier_1.stringify(falsyCondition);
		// Add truthy and falsy edges
		beginOfLoopBodyNode.appendConditionallyTo(testDecisionNode, truthyConditionLabel, truthyCondition);
		finalNode.appendConditionallyTo(testDecisionNode, falsyConditionLabel, falsyCondition);
	}
	else {
		// If the loop doesn't have a test expression,
		// the loop body starts unconditionally after the initialization
		beginOfLoopBodyNode.appendEpsilonEdgeTo(testDecisionNode);
	}
	context.enclosingStatements.push({
type: 1 /* OtherStatement */,
continueTarget: updateNode,
breakTarget: finalNode,
label: label
});
var loopBodyCompletion = statement_1.parseStatement(forStatement.body, beginOfLoopBodyNode, context);
context.enclosingStatements.pop();
if (forStatement.update) {
	// If the loop has an update expression,
	// parse it and append it to the end of the loop body
	var endOfUpdateNode = expression_1.parseExpression(forStatement.update, updateNode, context);
	testDecisionNode.appendEpsilonEdgeTo(endOfUpdateNode);
}
else {
	// If the loop doesn't have an update expression,
	// treat the update node as a dummy and point it to the test node
	testDecisionNode.appendEpsilonEdgeTo(updateNode);
}
if (loopBodyCompletion.normal) {
	// If we reached the end of the loop body through normal control flow,
	// continue regularly with the update
	updateNode.appendEpsilonEdgeTo(loopBodyCompletion.normal);
}
return { normal: finalNode };
}
exports.parseForStatement = parseForStatement;
function parseInit(init, currentNode, context) {
	if (init === null) {
		return { normal: currentNode };
	}
	if (init.type === ESTree.NodeType.VariableDeclaration) {
		return variable_1.parseVariableDeclaration(init, currentNode, context);
	}
	return {
normal: expression_1.parseExpression(init, currentNode, context)
	};
}
