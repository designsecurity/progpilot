var ESTree = require("../../estree");
function stringify(expression) {
	var stringifiers = (_a = {},
			_a[ESTree.NodeType.ArrayExpression] = stringifyArrayExpression,
			_a[ESTree.NodeType.AssignmentExpression] = stringifyAssignmentExpression,
			_a[ESTree.NodeType.BinaryExpression] = stringifyBinaryExpression,
			_a[ESTree.NodeType.CallExpression] = stringifyCallExpression,
			_a[ESTree.NodeType.ConditionalExpression] = stringifyConditionalExpression,
			_a[ESTree.NodeType.Identifier] = stringifyIdentifier,
			_a[ESTree.NodeType.Literal] = stringifyLiteral,
			_a[ESTree.NodeType.LogicalExpression] = stringifyLogicalExpression,
			_a[ESTree.NodeType.MemberExpression] = stringifyMemberExpression,
			_a[ESTree.NodeType.NewExpression] = stringifyNewExpression,
			_a[ESTree.NodeType.ObjectExpression] = stringifyObjectExpression,
			_a[ESTree.NodeType.SequenceExpression] = stringifySequenceExpression,
			_a[ESTree.NodeType.ThisExpression] = stringifyThisExpression,
			_a[ESTree.NodeType.UnaryExpression] = stringifyUnaryExpression,
			_a[ESTree.NodeType.UpdateExpression] = stringifyUpdateExpression,
			_a
			);
	var stringifier = stringifiers[expression.type];
	return stringifier
		? stringifier(expression)
		: "<UNEXPECTED>";
	var _a;
}
exports.stringify = stringify;
function stringifyArrayExpression(arrayExpression) {
	var stringifiedElements = "";
	var isFirstElement = true;
	var previousElementWasNull = false;
	for (var _i = 0, _a = arrayExpression.elements; _i < _a.length; _i++) {
		var element = _a[_i];
		if (!isFirstElement && !previousElementWasNull) {
			stringifiedElements += ",";
		}
		if (element === null) {
			stringifiedElements += ",";
			previousElementWasNull = true;
		}
		else {
			stringifiedElements += stringify(element);
			previousElementWasNull = false;
		}
		isFirstElement = false;
	}
	return "[" + stringifiedElements + "]";
}
function stringifyAssignmentExpression(assignmentExpression) {
	var left = stringify(assignmentExpression.left);
	var right = stringify(assignmentExpression.right);
	return left + " " + assignmentExpression.operator + " " + right;
}
function stringifyBinaryExpression(binaryExpression) {
	var left = stringify(binaryExpression.left);
	var right = stringify(binaryExpression.right);
	if (needsParenthesizing(binaryExpression.left)) {
		left = parenthesize(left);
	}
	if (needsParenthesizing(binaryExpression.right)) {
		right = parenthesize(right);
	}
	return left + " " + binaryExpression.operator + " " + right;
}
function stringifyCallExpression(callExpression) {
	var callee = stringify(callExpression.callee);
	var args = callExpression.arguments
		.map(function (arg) { return stringify(arg); })
		.join(", ");
	return callee + "(" + args + ")";
}
function stringifyConditionalExpression(conditionalExpression) {
	var test = stringify(conditionalExpression.test);
	var consequent = stringify(conditionalExpression.consequent);
	var alternate = stringify(conditionalExpression.alternate);
	if (needsParenthesizing(conditionalExpression.consequent)) {
		consequent = parenthesize(consequent);
	}
	if (needsParenthesizing(conditionalExpression.alternate)) {
		alternate = parenthesize(alternate);
	}
	return test + " ? " + consequent + " : " + alternate;
}
function stringifyIdentifier(identifier) {
	return identifier.name;
}
function stringifyLiteral(literal) {
	return literal.raw;
}
function stringifyLogicalExpression(logicalExpression) {
	var left = stringify(logicalExpression.left);
	var right = stringify(logicalExpression.right);
	if (needsParenthesizing(logicalExpression.left)) {
		left = parenthesize(left);
	}
	if (needsParenthesizing(logicalExpression.right)) {
		right = parenthesize(right);
	}
	return left + " " + logicalExpression.operator + " " + right;
}
function stringifyMemberExpression(memberExpression) {
	var object = stringify(memberExpression.object);
	var property = stringify(memberExpression.property);
	var left = needsParenthesizing(memberExpression.object)
		? parenthesize(object)
		: object;
	return memberExpression.computed
		? left + "[" + property + "]"
		: left + "." + property;
}
function stringifyNewExpression(newExpression) {
	var call = stringifyCallExpression(newExpression);
	return "new " + call;
}
function stringifyObjectExpression(objectExpression) {
	if (objectExpression.properties.length === 0) {
		return "{}";
	}
	var properties = objectExpression.properties.map(function (property) {
			var key = stringify(property.key);
			var value = stringify(property.value);
			return key + ": " + value;
			}).join(",\n    ");
	return "{\n    " + properties + "\n}";
}
function stringifySequenceExpression(sequenceExpression) {
	var expressions = sequenceExpression.expressions
		.map(stringify)
		.join(", ");
	return parenthesize(expressions);
}
function stringifyThisExpression(thisExpression) {
	return "this";
}
function stringifyUnaryExpression(unaryExpression) {
	var operator = unaryExpression.operator;
	var argument = stringify(unaryExpression.argument);
	var joiner = operator.length > 1 ? " " : "";
	if (needsParenthesizing(unaryExpression.argument)) {
		argument = parenthesize(argument);
	}
	return unaryExpression.prefix
		? operator + joiner + argument
		: argument + joiner + operator;
}
function stringifyUpdateExpression(updateExpression) {
	return updateExpression.prefix
		? updateExpression.operator + stringify(updateExpression.argument)
		: stringify(updateExpression.argument) + updateExpression.operator;
}
function needsParenthesizing(expression) {
	switch (expression.type) {
		case ESTree.NodeType.AssignmentExpression:
		case ESTree.NodeType.BinaryExpression:
		case ESTree.NodeType.ConditionalExpression:
		case ESTree.NodeType.LogicalExpression:
			return true;
		default:
			return false;
	}
}
function parenthesize(value) {
	return "(" + value + ")";
}
