var doWhile_1 = require("./doWhile");
var for_1 = require("./for");
var forIn_1 = require("./forIn");
var switch_1 = require("./switch");
var while_1 = require("./while");
var statement_1 = require("./statement");
var ESTree = require("../../estree");
function parseLabeledStatement(labeledStatement, currentNode, context)
{
    var body = labeledStatement.body;
    var label = labeledStatement.label.name;
    switch (body.type) {
        case ESTree.NodeType.BlockStatement:
        case ESTree.NodeType.IfStatement:
        case ESTree.NodeType.TryStatement:
        case ESTree.NodeType.WithStatement:
            return parseLabeledEnclosingStatement(labeledStatement, currentNode, context, label);
        case ESTree.NodeType.SwitchStatement:
            return switch_1.parseSwitchStatement(body, currentNode, context, label);
        case ESTree.NodeType.WhileStatement:
            return while_1.parseWhileStatement(body, currentNode, context, label);
        case ESTree.NodeType.DoWhileStatement:
            return doWhile_1.parseDoWhileStatement(body, currentNode, context, label);
        case ESTree.NodeType.ForStatement:
            return for_1.parseForStatement(body, currentNode, context, label);
        case ESTree.NodeType.ForInStatement:
            return forIn_1.parseForInStatement(body, currentNode, context, label);
        default:
            // If we didn't encounter an enclosing statement,
            // the label is irrelevant for control flow and we thus don't track it.
            return statement_1.parseStatement(body, currentNode, context);
    }
}
exports.parseLabeledStatement = parseLabeledStatement;
function parseLabeledEnclosingStatement(labeledStatement, currentNode, context, label)
{
    var finalNode = context.createNode();
    var enclosingStatement = {
        type: 1 /* OtherStatement */,
        breakTarget: finalNode,
        continueTarget: null,
        label: label
    };
    context.enclosingStatements.push(enclosingStatement);
    var bodyCompletion = statement_1.parseStatement(labeledStatement.body, currentNode, context);
    context.enclosingStatements.pop();
    if (bodyCompletion.normal) {
        finalNode.appendEpsilonEdgeTo(bodyCompletion.normal);
        return { normal: finalNode };
    }
    return bodyCompletion;
}
